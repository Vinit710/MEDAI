{"version":3,"sources":["../../src/utils/RequestController.ts","../../src/utils/toInteractiveRequest.ts","../../src/utils/emitAsync.ts"],"names":[],"mappings":";AAAA,SAAS,iBAAiB;AAC1B,SAAS,uBAAuB;AAEzB,IAAM,oBAAN,MAAwB;AAAA,EAG7B,YAAsB,SAAkB;AAAlB;AACpB,SAAK,kBAAkB,IAAI,gBAAgB;AAAA,EAC7C;AAAA,EAEO,YAAY,UAA2B;AAC5C;AAAA,MACE,KAAK,gBAAgB,UAAU;AAAA,MAC/B;AAAA,MACA,KAAK,QAAQ;AAAA,MACb,KAAK,QAAQ;AAAA,IACf;AAEA,SAAK,gBAAgB,QAAQ,QAAQ;AAAA,EACvC;AACF;;;ACdO,SAAS,qBAAqB,SAGnC;AACA,QAAM,oBAAoB,IAAI,kBAAkB,OAAO;AAEvD,UAAQ;AAAA,IACN;AAAA,IACA;AAAA,IACA,kBAAkB,YAAY,KAAK,iBAAiB;AAAA,EACtD;AAEA,SAAO;AAAA,IACL,oBAAoB;AAAA,IACpB;AAAA,EACF;AACF;;;ACfA,eAAsB,UAIpB,SACA,cACG,MACY;AACf,QAAM,WAAW,QAAQ,UAAU,SAAS;AAE5C,MAAI,SAAS,WAAW,GAAG;AACzB;AAAA,EACF;AAEA,aAAW,YAAY,UAAU;AAC/B,UAAM,SAAS,MAAM,SAAS,IAAI;AAAA,EACpC;AACF","sourcesContent":["import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport class RequestController {\n  public responsePromise: DeferredPromise<Response | undefined>\n\n  constructor(protected request: Request) {\n    this.responsePromise = new DeferredPromise()\n  }\n\n  public respondWith(response?: Response): void {\n    invariant(\n      this.responsePromise.state === 'pending',\n      'Failed to respond to \"%s %s\" request: the \"request\" event has already been responded to.',\n      this.request.method,\n      this.request.url\n    )\n\n    this.responsePromise.resolve(response)\n  }\n}\n","import { RequestController } from './RequestController'\n\nexport type InteractiveRequest = globalThis.Request & {\n  respondWith: RequestController['respondWith']\n}\n\nexport function toInteractiveRequest(request: Request): {\n  interactiveRequest: InteractiveRequest\n  requestController: RequestController\n} {\n  const requestController = new RequestController(request)\n\n  Reflect.set(\n    request,\n    'respondWith',\n    requestController.respondWith.bind(requestController)\n  )\n\n  return {\n    interactiveRequest: request as InteractiveRequest,\n    requestController,\n  }\n}\n","import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listners = emitter.listeners(eventName)\n\n  if (listners.length === 0) {\n    return\n  }\n\n  for (const listener of listners) {\n    await listener.apply(emitter, data)\n  }\n}\n"]}